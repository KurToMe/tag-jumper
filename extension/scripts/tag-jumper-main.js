// Generated by CoffeeScript 1.3.3
var DomParser, ElementArticulator, tjump,
  __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; };

tjump = {};

tjump.overlay = document.createElement('div');

tjump.overlay.id = 'main-overlay';

tjump.overlay.className += 'overlay';

tjump.canvas = document.createElement('canvas');

tjump.canvas.id = 'main-canvas';

tjump.canvas.className += 'canvas';

tjump.overlay.appendChild(tjump.canvas);

tjump.ctx = tjump.canvas.getContext("2d");

document.body.appendChild(tjump.overlay);

tjump.SCALE = 32.0;

tjump.FRAME_RATE = 1.0 / 60;

tjump.VELOCITY_ITERATIONS = 10;

tjump.POSITION_ITERATIONS = 10;

tjump.GRAVITY = new Box2D.Common.Math.b2Vec2(0, 0);

tjump.getWidth = function() {
  return tjump.canvas.offsetWidth;
};

tjump.getHeight = function() {
  return tjump.canvas.offsetHeight;
};

/*
 Converts screen points (pixels) to points the 
 physics engine works with
*/


tjump.scaleToPhys = function(x) {
  return x / tjump.SCALE;
};

/*
 Converts screen points (pixels) vector to points 
 the physics engine works with
*/


tjump.scaleVecToPhys = function(vec) {
  vec.Multiply(1 / tjump.SCALE);
  return vec;
};

/*
 Converts physics points to points the screen points
 (pixels)
*/


tjump.scaleToScreen = function(x) {
  return x * tjump.SCALE;
};

/*
# Applies a horizontal force to a body
*/


tjump.applyXForce = function(body, xForce) {
  var b2Vec2, centerPoint, force;
  b2Vec2 = Box2D.Common.Math.b2Vec2;
  centerPoint = body.GetPosition();
  force = new b2Vec2(xForce, 0);
  return body.ApplyForce(force, centerPoint);
};

/*
# Applies a vertical force to a body
*/


tjump.applyYForce = function(body, yForce) {
  var b2Vec2, centerPoint, force;
  b2Vec2 = Box2D.Common.Math.b2Vec2;
  centerPoint = body.GetPosition();
  force = new b2Vec2(0, yForce);
  return body.ApplyForce(force, centerPoint);
};

tjump.isBodyInContact = function(contact, body) {
  var bodyA, bodyB;
  bodyA = contact.GetFixtureA().GetBody();
  bodyB = contact.GetFixtureB().GetBody();
  if (bodyA === body || bodyB === body) {
    return true;
  } else {
    return false;
  }
};

ElementArticulator = (function() {

  function ElementArticulator() {
    this.isValid = __bind(this.isValid, this);

    this.articulateElement = __bind(this.articulateElement, this);

  }

  ElementArticulator.prototype.articulateElement = function(element) {
    var platformDef;
    if (!this.isValid(element)) {
      return false;
    }
    platformDef = {
      top: element.offsetTop,
      left: element.offsetLeft,
      width: element.offsetWidth
    };
    tjump.createPlatform(platformDef);
    return true;
  };

  ElementArticulator.prototype.isValid = function(element) {
    if (!element.offsetWidth) {
      return false;
    }
    if (element.offsetWidth > tjump.canvas.offsetWidth / 3) {
      return false;
    }
    if (element.offsetHeight > tjump.canvas.offsetHeight / 3) {
      return false;
    }
    if (element.offsetWidth < 5) {
      return false;
    }
    if (element.offsetHeight < 5) {
      return false;
    }
    return true;
  };

  return ElementArticulator;

})();

/*
# Able to parse the DOM and return a set of interesting 
# html elements for the page.
*/


DomParser = (function() {
  /*
  	# Constructor
  */

  function DomParser(articulator) {
    this.articulator = articulator;
    this.parseElement = __bind(this.parseElement, this);

    this.parsePage = __bind(this.parsePage, this);

  }

  DomParser.prototype.parsePage = function() {
    return this.parseElement(document.body);
  };

  DomParser.prototype.parseElement = function(element) {
    var child, wasArticulated, _i, _len, _ref, _results;
    wasArticulated = this.articulator.articulateElement(element);
    if (wasArticulated) {
      return;
    }
    _ref = element.childNodes;
    _results = [];
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      child = _ref[_i];
      _results.push(this.parseElement(child));
    }
    return _results;
  };

  return DomParser;

})();

/*
 Function that animates the
*/


window.requestAnimFrame = (function() {
  return window.requestAnimationFrame || window.webkitRequestAnimationFrame || window.mozRequestAnimationFrame || window.oRequestAnimationFrame || window.msRequestAnimationFrame || function(callback, element) {
    return window.setTimeout(callback, 1000 / 60);
  };
})();

/*
 Creates a horizontal platform
*/


tjump.createPlatform = function(platformDef) {
  var b2Body, b2BodyDef, b2FixtureDef, b2PolygonShape, bodyDef, fixDef, height, platform, width;
  b2BodyDef = Box2D.Dynamics.b2BodyDef;
  b2Body = Box2D.Dynamics.b2Body;
  b2FixtureDef = Box2D.Dynamics.b2FixtureDef;
  b2PolygonShape = Box2D.Collision.Shapes.b2PolygonShape;
  fixDef = new b2FixtureDef;
  fixDef.density = 1.0;
  fixDef.friction = 1;
  fixDef.restitution = 1;
  bodyDef = new b2BodyDef;
  bodyDef.type = b2Body.b2_staticBody;
  fixDef.shape = new b2PolygonShape;
  bodyDef.position.x = tjump.scaleToPhys(platformDef.left - (tjump.getWidth() / 2));
  bodyDef.position.y = tjump.scaleToPhys(-1 * (platformDef.top - (tjump.getHeight() / 2)));
  width = tjump.scaleToPhys(platformDef.width);
  height = tjump.scaleToPhys(5.0);
  fixDef.shape.SetAsBox(width, height);
  platform = tjump.world.CreateBody(bodyDef);
  return platform.CreateFixture(fixDef);
};

/*
 Handles the BeginContact event from the physics 
 world.
*/


tjump.beginContact = function(contact) {
  return tjump.paddleAi.beginContact(contact);
};

/*
 Initalizes everything we need to get started, should
 only be called once to set up.
*/


tjump.init = function() {
  var allowSleep, b2DebugDraw, debugDraw, listener;
  b2DebugDraw = Box2D.Dynamics.b2DebugDraw;
  allowSleep = true;
  tjump.world = new Box2D.Dynamics.b2World(tjump.GRAVITY, allowSleep);
  tjump.elementArticulator = new ElementArticulator();
  tjump.domParser = new DomParser(tjump.elementArticulator);
  tjump.domParser.parsePage();
  listener = new Box2D.Dynamics.b2ContactListener;
  listener.BeginContact = tjump.beginContact;
  tjump.world.SetContactListener(listener);
  debugDraw = new b2DebugDraw();
  debugDraw.SetSprite(tjump.ctx);
  debugDraw.SetDrawScale(tjump.SCALE);
  debugDraw.SetFillAlpha(0.4);
  debugDraw.SetLineThickness(1.0);
  debugDraw.SetFlags(b2DebugDraw.e_shapeBit | b2DebugDraw.e_jointBit);
  return tjump.world.SetDebugDraw(debugDraw);
};

/*
 Does all the work we need to do at each tick of the
 game clock.
*/


tjump.update = function() {
  tjump.world.Step(tjump.FRAME_RATE, tjump.VELOCITY_ITERATIONS, tjump.POSITION_ITERATIONS);
  tjump.world.DrawDebugData();
  tjump.world.ClearForces();
  return requestAnimFrame(tjump.update);
};

tjump.init();

requestAnimFrame(tjump.update);
