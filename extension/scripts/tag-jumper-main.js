// Generated by CoffeeScript 1.3.3
var DomParser, ElementArticulator, GameUi, tjump,
  __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; };

tjump = {};

tjump.overlay = document.createElement('div');

tjump.overlay.id = 'main-overlay';

tjump.overlay.className += 'overlay';

tjump.canvas = document.createElement('canvas');

tjump.canvas.id = 'main-canvas';

tjump.canvas.className += 'canvas';

tjump.overlay.appendChild(tjump.canvas);

tjump.ctx = tjump.canvas.getContext("2d");

document.body.appendChild(tjump.overlay);

tjump.SCALE = 32.0;

tjump.FRAME_RATE = 1.0 / 60;

tjump.VELOCITY_ITERATIONS = 10;

tjump.POSITION_ITERATIONS = 10;

tjump.GRAVITY = new Box2D.Common.Math.b2Vec2(0, 0);

tjump.getWidth = function() {
  return tjump.canvas.offsetWidth;
};

tjump.getHeight = function() {
  return tjump.canvas.offsetHeight;
};

/*
 Converts screen points (pixels) to points the 
 physics engine works with
*/


tjump.scaleToPhys = function(x) {
  return x / tjump.SCALE;
};

/*
 Converts screen points (pixels) vector to points 
 the physics engine works with
*/


tjump.scaleVecToPhys = function(vec) {
  vec.Multiply(1 / tjump.SCALE);
  return vec;
};

/*
 Converts physics points to points the screen points
 (pixels)
*/


tjump.scaleToScreen = function(x) {
  return x * tjump.SCALE;
};

/*
# Applies a horizontal force to a body
*/


tjump.applyXForce = function(body, xForce) {
  var b2Vec2, centerPoint, force;
  b2Vec2 = Box2D.Common.Math.b2Vec2;
  centerPoint = body.GetPosition();
  force = new b2Vec2(xForce, 0);
  return body.ApplyForce(force, centerPoint);
};

/*
# Applies a vertical force to a body
*/


tjump.applyYForce = function(body, yForce) {
  var b2Vec2, centerPoint, force;
  b2Vec2 = Box2D.Common.Math.b2Vec2;
  centerPoint = body.GetPosition();
  force = new b2Vec2(0, yForce);
  return body.ApplyForce(force, centerPoint);
};

tjump.isBodyInContact = function(contact, body) {
  var bodyA, bodyB;
  bodyA = contact.GetFixtureA().GetBody();
  bodyB = contact.GetFixtureB().GetBody();
  if (bodyA === body || bodyB === body) {
    return true;
  } else {
    return false;
  }
};

GameUi = (function() {

  function GameUi(canvas, world, loopCallback) {
    this.createTextActor = __bind(this.createTextActor, this);

    this.createRectActorWithBody = __bind(this.createRectActorWithBody, this);

    this.bodyFromActor = __bind(this.bodyFromActor, this);

    var fps, height, width;
    width = canvas.offsetWidth;
    height = canvas.offsetHeight;
    this.director = new CAAT.Director().initialize(width, height, canvas);
    this.scene = this.director.createScene();
    CAAT.PMR = tjump.SCALE;
    CAAT.enableBox2DDebug(true, this.director, world);
    this.scene.onRenderStart = loopCallback;
    fps = 45;
    CAAT.loop(fps);
  }

  GameUi.prototype.bodyFromActor = function(actor, world) {
    return CAAT.B2DPolygonBody.createPolygonBody(world, {
      x: actor.x,
      y: actor.y,
      bodyType: Box2D.Dynamics.b2Body.b2_staticBody,
      density: 1,
      restitution: 1,
      friction: 1,
      image: null,
      polygonType: CAAT.B2DPolygonBody.Type.BOX,
      bodyDef: [
        {
          x: actor.x,
          y: actor.y
        }, {
          x: actor.x + actor.width,
          y: actor.y + actor.height
        }
      ],
      bodyDefScale: 1,
      bodyDefScaleTolerance: 0,
      userData: {}
    });
  };

  GameUi.prototype.createRectActorWithBody = function(def, world) {
    var actor, body;
    actor = new CAAT.Actor().setLocation(def.left, def.top).setSize(def.width, def.height).setFillStyle('orange');
    this.scene.addChild(actor);
    body = this.bodyFromActor(actor, world);
    return body;
  };

  GameUi.prototype.createTextActor = function(def) {
    var actor;
    actor = new CAAT.TextActor().setLocation(def.left, def.top).setText(def.htmlId).setFillStyle('black');
    return this.scene.addChild(actor);
  };

  return GameUi;

})();

ElementArticulator = (function() {

  function ElementArticulator() {
    this.isValid = __bind(this.isValid, this);

    this.articulateElement = __bind(this.articulateElement, this);

  }

  ElementArticulator.prototype.articulateElement = function(element) {
    var platformDef;
    if (!this.isValid(element)) {
      return false;
    }
    if (Math.random() > .5) {
      return false;
    }
    platformDef = {
      top: element.offsetTop,
      left: element.offsetLeft,
      width: element.offsetWidth,
      height: 5,
      htmlId: element.id
    };
    tjump.createPlatform(platformDef);
    return true;
  };

  ElementArticulator.prototype.isValid = function(element) {
    if (!element.offsetWidth) {
      return false;
    }
    if (element.offsetWidth > tjump.canvas.offsetWidth / 3) {
      return false;
    }
    if (element.offsetHeight > tjump.canvas.offsetHeight / 3) {
      return false;
    }
    if (element.offsetWidth < 5) {
      return false;
    }
    if (element.offsetHeight < 5) {
      return false;
    }
    return true;
  };

  return ElementArticulator;

})();

/*
# Able to parse the DOM and return a set of interesting 
# html elements for the page.
*/


DomParser = (function() {
  /*
  	# Constructor
  */

  function DomParser(articulator) {
    this.articulator = articulator;
    this.parseElement = __bind(this.parseElement, this);

    this.parsePage = __bind(this.parsePage, this);

  }

  DomParser.prototype.parsePage = function() {
    this.elementCount = 0;
    return this.parseElement(document.body);
  };

  DomParser.prototype.parseElement = function(element) {
    var child, wasArticulated, _i, _len, _ref, _results;
    wasArticulated = this.articulator.articulateElement(element);
    this.elementCount++;
    if (this.elementCount > 30000) {
      return;
    }
    _ref = element.childNodes;
    _results = [];
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      child = _ref[_i];
      _results.push(this.parseElement(child));
    }
    return _results;
  };

  return DomParser;

})();

/*
 Function that animates the
*/


window.requestAnimFrame = (function() {
  return window.requestAnimationFrame || window.webkitRequestAnimationFrame || window.mozRequestAnimationFrame || window.oRequestAnimationFrame || window.msRequestAnimationFrame || function(callback, element) {
    return window.setTimeout(callback, 1000 / 60);
  };
})();

/*
 Creates a horizontal platform
*/


tjump.createPlatform = function(platformDef) {
  return tjump.ui.createRectActorWithBody(platformDef, tjump.world);
};

/*
 Handles the BeginContact event from the physics 
 world.
*/


tjump.beginContact = function(contact) {};

/*
 Does all the work we need to do at each tick of the
 game clock.
*/


tjump.update = function() {
  tjump.world.Step(tjump.FRAME_RATE, tjump.VELOCITY_ITERATIONS, tjump.POSITION_ITERATIONS);
  tjump.world.DrawDebugData();
  return tjump.world.ClearForces();
};

/*
 Initalizes everything we need to get started, should
 only be called once to set up.
*/


tjump.init = function() {
  var allowSleep, b2DebugDraw, debugDraw, listener;
  b2DebugDraw = Box2D.Dynamics.b2DebugDraw;
  allowSleep = true;
  tjump.world = new Box2D.Dynamics.b2World(tjump.GRAVITY, allowSleep);
  tjump.elementArticulator = new ElementArticulator();
  tjump.domParser = new DomParser(tjump.elementArticulator);
  tjump.ui = new GameUi(tjump.canvas, tjump.world, tjump.update);
  tjump.domParser.parsePage();
  listener = new Box2D.Dynamics.b2ContactListener;
  listener.BeginContact = tjump.beginContact;
  tjump.world.SetContactListener(listener);
  debugDraw = new b2DebugDraw();
  debugDraw.SetSprite(tjump.ctx);
  debugDraw.SetDrawScale(tjump.SCALE);
  debugDraw.SetFillAlpha(0.4);
  debugDraw.SetLineThickness(1.0);
  debugDraw.SetFlags(b2DebugDraw.e_shapeBit | b2DebugDraw.e_jointBit);
  return tjump.world.SetDebugDraw(debugDraw);
};

tjump.init();
