// Generated by CoffeeScript 1.4.0
var DomParser, ElementActor, ElementArticulator, GameUi, tjump,
  __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; };

tjump = {};

tjump.overlay = document.createElement('div');

tjump.overlay.id = 'main-overlay';

tjump.overlay.className += 'overlay';

tjump.canvas = document.createElement('canvas');

tjump.canvas.id = 'main-canvas';

tjump.canvas.className += 'canvas';

tjump.overlay.appendChild(tjump.canvas);

tjump.ctx = tjump.canvas.getContext("2d");

tjump.$document = $(document);

document.body.appendChild(tjump.overlay);

tjump.SCALE = 32.0;

tjump.FRAME_RATE = 1.0 / 60;

tjump.VELOCITY_ITERATIONS = 10;

tjump.POSITION_ITERATIONS = 10;

tjump.GRAVITY = new Box2D.Common.Math.b2Vec2(9.8, 5);

tjump.getWidth = function() {
  return tjump.canvas.offsetWidth;
};

tjump.getHeight = function() {
  return tjump.canvas.offsetHeight;
};

/*
 Converts screen points (pixels) to points the 
 physics engine works with
*/


tjump.scaleToPhys = function(x) {
  return x / tjump.SCALE;
};

/*
 Converts screen points (pixels) vector to points 
 the physics engine works with
*/


tjump.scaleVecToPhys = function(vec) {
  vec.Multiply(1 / tjump.SCALE);
  return vec;
};

/*
 Converts physics points to points the screen points
 (pixels)
*/


tjump.scaleToScreen = function(x) {
  return x * tjump.SCALE;
};

/*
# Applies a horizontal force to a body
*/


tjump.applyXForce = function(body, xForce) {
  var b2Vec2, centerPoint, force;
  b2Vec2 = Box2D.Common.Math.b2Vec2;
  centerPoint = body.GetPosition();
  force = new b2Vec2(xForce, 0);
  return body.ApplyForce(force, centerPoint);
};

/*
# Applies a vertical force to a body
*/


tjump.applyYForce = function(body, yForce) {
  var b2Vec2, centerPoint, force;
  b2Vec2 = Box2D.Common.Math.b2Vec2;
  centerPoint = body.GetPosition();
  force = new b2Vec2(0, yForce);
  return body.ApplyForce(force, centerPoint);
};

tjump.isBodyInContact = function(contact, body) {
  var bodyA, bodyB;
  bodyA = contact.GetFixtureA().GetBody();
  bodyB = contact.GetFixtureB().GetBody();
  if (bodyA === body || bodyB === body) {
    return true;
  } else {
    return false;
  }
};

ElementActor = (function() {

  function ElementActor(element, actor) {
    this.element = element;
    this.actor = actor;
    this.update = __bind(this.update, this);

    this.isVisible = __bind(this.isVisible, this);

    this.getLocation = __bind(this.getLocation, this);

    this.$element = $(element);
  }

  ElementActor.prototype.getLocation = function() {
    var def;
    def = {
      top: this.$element.offset().top - tjump.$document.scrollTop(),
      left: this.$element.offset().left - tjump.$document.scrollLeft()
    };
    return def;
  };

  ElementActor.prototype.isVisible = function() {
    return this.$element.is(":visible");
  };

  ElementActor.prototype.update = function() {
    var def;
    if (this.isVisible()) {
      def = this.getLocation();
      this.actor.setVisible(true);
      return this.actor.setLocation(def.left, def.top);
    } else {
      return this.actor.setVisible(false);
    }
  };

  return ElementActor;

})();

GameUi = (function() {

  function GameUi(canvas, world, loopCallback) {
    var height, width;
    this.world = world;
    this.createTextActor = __bind(this.createTextActor, this);

    this.createRectActorWithBody = __bind(this.createRectActorWithBody, this);

    this.rectBodyFromActor = __bind(this.rectBodyFromActor, this);

    this.bodyFromActor = __bind(this.bodyFromActor, this);

    width = canvas.offsetWidth;
    height = canvas.offsetHeight;
    this.director = new CAAT.Director().initialize(width, height, canvas);
    this.scene = this.director.createScene();
    CAAT.PMR = tjump.SCALE;
    CAAT.enableBox2DDebug(true, this.director, this.world);
    this.scene.onRenderStart = loopCallback;
    CAAT.loop(tjump.FRAME_RATE);
  }

  GameUi.prototype.getDefaultBodyDef = function(actor) {
    var def;
    def = {
      x: actor.x,
      y: actor.y,
      bodyType: Box2D.Dynamics.b2Body.b2_staticBody,
      density: 1,
      restitution: 1,
      friction: 1,
      image: null,
      polygonType: CAAT.B2DPolygonBody.Type.BOX,
      bodyDef: [
        {
          x: actor.x,
          y: actor.y
        }, {
          x: actor.x + actor.width,
          y: actor.y + actor.height
        }
      ],
      bodyDefScale: 1,
      bodyDefScaleTolerance: 0,
      userData: {}
    };
    return def;
  };

  GameUi.prototype.bodyFromActor = function(actor, bodyDef) {
    var body;
    body = CAAT.B2DPolygonBody.createPolygonBody(this.world, bodyDef);
    return body;
  };

  GameUi.prototype.rectBodyFromActor = function(actor) {
    var body;
    body = CAAT.B2DPolygonBody.createPolygonBody(this.world, this.getDefaultBodyDef(actor));
    return body;
  };

  GameUi.prototype.createRectActorWithBody = function(def, world) {
    var actor;
    this.world = world;
    actor = new CAAT.Actor().setLocation(def.left, def.top).setSize(def.width, def.height).setFillStyle('orange').setAlpha(.6);
    this.scene.addChild(actor);
    return actor;
  };

  GameUi.prototype.createTextActor = function(def) {
    var actor;
    actor = new CAAT.TextActor().setLocation(def.left, def.top).setText(def.text).setFillStyle('black');
    this.scene.addChild(actor);
    return actor;
  };

  return GameUi;

})();

ElementArticulator = (function() {

  function ElementArticulator() {
    this.isValid = __bind(this.isValid, this);

    this.articulateElement = __bind(this.articulateElement, this);

  }

  ElementArticulator.prototype.articulateElement = function(element) {
    if (!this.isValid(element)) {
      return false;
    }
    if (Math.random() < .9) {
      return false;
    }
    tjump.createPlatform(element);
    return true;
  };

  ElementArticulator.prototype.isValid = function(element) {
    if (!element.offsetWidth) {
      return false;
    }
    if (element.offsetWidth > tjump.canvas.offsetWidth / 2) {
      return false;
    }
    if (element.offsetHeight > tjump.canvas.offsetHeight / 2) {
      return false;
    }
    if (element.offsetWidth < 5) {
      return false;
    }
    if (element.offsetHeight < 5) {
      return false;
    }
    return true;
  };

  return ElementArticulator;

})();

/*
# Able to parse the DOM and return a set of interesting 
# html elements for the page.
*/


DomParser = (function() {
  /*
  	# Constructor
  */

  function DomParser(articulator) {
    this.articulator = articulator;
    this.parseElement = __bind(this.parseElement, this);

    this.parsePage = __bind(this.parsePage, this);

  }

  DomParser.prototype.parsePage = function() {
    this.elementCount = 0;
    return this.parseElement(document.body);
  };

  DomParser.prototype.parseElement = function(element) {
    var child, wasArticulated, _i, _len, _ref, _results;
    wasArticulated = this.articulator.articulateElement(element);
    this.elementCount++;
    if (this.elementCount > 30000) {
      return;
    }
    _ref = element.childNodes;
    _results = [];
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      child = _ref[_i];
      _results.push(this.parseElement(child));
    }
    return _results;
  };

  return DomParser;

})();

/*
 Creates a horizontal platform
*/


tjump.createPlatform = function(element) {
  var actor, body, platformDef;
  platformDef = {
    top: element.offsetTop,
    left: element.offsetLeft,
    width: element.offsetWidth,
    height: element.offsetHeight
  };
  actor = tjump.ui.createRectActorWithBody(platformDef, tjump.world);
  body = tjump.ui.rectBodyFromActor(actor);
  return tjump.updatables.push(new ElementActor(element, actor));
};

tjump.createPlayer = function() {
  var actor, body, bodyDef, platformDef;
  platformDef = {
    top: 200,
    left: 200,
    width: 10,
    height: 20
  };
  actor = tjump.ui.createRectActorWithBody(platformDef, tjump.world);
  actor.setFillStyle('green');
  actor.setAlpha(.8);
  bodyDef = tjump.ui.getDefaultBodyDef(actor);
  bodyDef.bodyType = Box2D.Dynamics.b2Body.b2_dynamicBody;
  body = tjump.ui.bodyFromActor(actor, bodyDef);
  return tjump.updatables.push(new ElementActor(element, actor));
};

/*
 Handles the BeginContact event from the physics 
 world.
*/


tjump.beginContact = function(contact) {};

/*
 Does all the work we need to do at each tick of the
 game clock.
*/


tjump.update = function() {
  var updatable, _i, _len, _ref, _results;
  tjump.world.Step(tjump.FRAME_RATE, tjump.VELOCITY_ITERATIONS, tjump.POSITION_ITERATIONS);
  tjump.world.ClearForces();
  _ref = tjump.updatables;
  _results = [];
  for (_i = 0, _len = _ref.length; _i < _len; _i++) {
    updatable = _ref[_i];
    _results.push(updatable.update());
  }
  return _results;
};

/*
 Initalizes everything we need to get started, should
 only be called once to set up.
*/


tjump.init = function() {
  var allowSleep, b2DebugDraw, debugDraw, listener;
  tjump.updatables = [];
  b2DebugDraw = Box2D.Dynamics.b2DebugDraw;
  allowSleep = true;
  tjump.world = new Box2D.Dynamics.b2World(tjump.GRAVITY, allowSleep);
  tjump.elementArticulator = new ElementArticulator();
  tjump.domParser = new DomParser(tjump.elementArticulator);
  tjump.ui = new GameUi(tjump.canvas, tjump.world, tjump.update);
  tjump.domParser.parsePage();
  listener = new Box2D.Dynamics.b2ContactListener;
  listener.BeginContact = tjump.beginContact;
  tjump.world.SetContactListener(listener);
  tjump.createPlayer();
  setup(debug(draw));
  debugDraw = new b2DebugDraw();
  debugDraw.SetSprite(tjump.ctx);
  debugDraw.SetDrawScale(tjump.SCALE);
  debugDraw.SetFillAlpha(0.4);
  debugDraw.SetLineThickness(1.0);
  debugDraw.SetFlags(b2DebugDraw.e_shapeBit | b2DebugDraw.e_jointBit);
  return tjump.world.SetDebugDraw(debugDraw);
};

tjump.init();
